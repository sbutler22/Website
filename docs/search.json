[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sam Butler Data Projects",
    "section": "",
    "text": "Hi!\nI’m Sam Butler. I am a Math Major at Pomona college, focusing in statistics and data science. This website is home to the projects I have worked on, particularly while spending a summer leading outdoor trips for teenagers, and studying abroad in Montpellier, France, both chapters where I have been away from math and stats classes, but have still been working in R."
  },
  {
    "objectID": "400_Data.html",
    "href": "400_Data.html",
    "title": "400_Data",
    "section": "",
    "text": "the data\nthe data comes from the Pomona-Pitzer track team which is a Division 3 collegiate program. much of it is times collected through a laser timing system used on days when the team is doing short-sprinting work. An interest of this analysis is to see how the success of 400 meter athletes in the short-sprinting work compares to their abilities in the actual 400 meter races. This is of interest because the 400 is a long enough event that it requires both aerobic and anaerobic strengths, the balance of which can vary from athlete to athlete. the data is too small to make any legitimate conclusions, but will be cool to explore nonetheless!\n\n\nquestion\nhow do both standing and flying 30 meter times correspond to 400 performance?\n\n# first find average of five fastest times in each 30m category\nthirties &lt;- four_hund_data[, grep(\"30\", names(four_hund_data))] \n  \n# replace \"NA\" with 0 so that we can order the columns\nthirties[is.na(thirties)] &lt;- 0\n\nordered_thirties &lt;- as.data.frame(apply(thirties, 2, sort))\n\n# finding the 5 lowest values\nfind_five_lowest_non_zero &lt;- function(column_data) {\n  non_zero_values &lt;- column_data[column_data != 0]\n  sorted_values &lt;- sort(non_zero_values)\n  five_lowest_values &lt;- head(sorted_values, 5)\n  return(five_lowest_values)\n}\n\nfastest_five &lt;- apply(ordered_thirties, 2, find_five_lowest_non_zero) \n\n# in order to find the average of the fastest five, we need all vectors to actually be five values\n# finding the max_length\nmax_length &lt;- max(sapply(fastest_five, length))\n\n# pad vectors with NAs to make them equal length\npadded_list &lt;- lapply(fastest_five, function(x) {\n  length(x) &lt;- max_length\n  return(x)\n})\n\n# convert padded list to dataframe\nfastest_five_df &lt;- data.frame(padded_list)\n\n# now we can calculate the averages\ntop_five_avgs &lt;- colMeans(fastest_five_df, na.rm = TRUE)\n\ntop_five_avgs_df &lt;- data.frame(top_five_avgs)\n\nnow we can get our 400 performances\n\nfour_hundreds &lt;- four_hund_data[, grep(\"400\", names(four_hund_data))] \n\n# get the fastest performances\nmin_values &lt;- apply(four_hundreds, 2, min, na.rm = TRUE)\n\nfastest_four_hundreds &lt;- data.frame(min_values)\n\n\n# want to make a dataframe that allows us to compare 30s and 400s\nstand_thirties &lt;- top_five_avgs_df[seq(1, nrow(top_five_avgs_df), by = 2), ]\nfly_thirties &lt;- top_five_avgs_df[seq(2, nrow(top_five_avgs_df), by = 2), ]\n\nfastest_stand_thirties &lt;- data.frame(stand_thirties)\nfastest_fly_thirties &lt;- data.frame(fly_thirties)\n\n\ntotal_df &lt;- cbind(fastest_four_hundreds, fastest_stand_thirties, fastest_fly_thirties) %&gt;%\n  mutate(athletes = c(\"Sam\", \"Jake\", \"Fox\", \"Jalen\", \"Rylan\", \"Seb\", \"Olivia\", \"Nicole\", \"Kensi\", \"Anna\"))\n\n\ntotal_df %&gt;%\n  ggplot() +\n  geom_col(aes(x = stand_thirties, y = min_values, fill = athletes)) +\nscale_fill_manual(values = c(\"Sam\" = \"black\", \"Jake\" = \"magenta\", \"Fox\" = \"purple\", \"Seb\" = \"darkblue\", \"Jalen\" = \"red\", \"Rylan\" = \"maroon\", \"Olivia\" = \"lightgreen\", \"Nicole\" = \"green\", \"Kensi\" = \"darkgreen\", \"Anna\" = \"orange\"),\n                     breaks = c(\"Jake\", \"Sam\",  \"Seb\", \"Fox\", \"Jalen\", \"Rylan\", \"Kensi\", \"Olivia\", \"Anna\", \"Nicole\")) +\n  xlab(\"standing 30 meter PRs\") +\n  ylab(\"400 meter PRs\") +\n  coord_cartesian(ylim = c(45, 65))\n\n\n\n\n\n\n\n\nathletes with lower bars relative to those clustered around them, (Sam, Fox, & Olivia), are more “strength based” athletes. they have better 400 meter PRs with the same acceleration as those around them. so it is likely that their strength comes from somewhere else.\nnow we might want to see how fly 30 Meter times compare to 400 meter PRs. since the fly times tell us more about max velocity than they do about acceleration, they might be more informative.\n\ntotal_df %&gt;%\n  ggplot() +\n  geom_col(aes(x = fly_thirties, y = min_values, fill = athletes), width = 0.005) +\n  scale_fill_manual(values = c(\"Sam\" = \"black\", \"Jake\" = \"magenta\", \"Fox\" = \"purple\", \"Seb\" = \"darkblue\", \"Jalen\" = \"red\", \"Rylan\" = \"maroon\", \"Olivia\" = \"lightgreen\", \"Nicole\" = \"green\", \"Kensi\" = \"darkgreen\", \"Anna\" = \"orange\"),\n                     breaks = c(\"Jake\", \"Sam\", \"Seb\", \"Jalen\", \"Fox\", \"Rylan\", \"Olivia\", \"Kensi\", \"Nicole\", \"Anna\")) +\n  xlab(\"fly 30 meter PRs\") +\n  ylab(\"400 meter PRs\") +\n  coord_cartesian(ylim = c(45, 65)) \n\n\n\n\n\n\n\n\nSam and Olivia’s fly 30 meter PRs move them closer to the fast end of their respective groups which tells us that max velocity might correspond more directly with their 400 meter ability. Fox however is still in a similar spot relative to the others, which makes sense because he is historically an 800/1500 meter runner so his strengths are truly more aerobic."
  },
  {
    "objectID": "400_Data.html#the-data",
    "href": "400_Data.html#the-data",
    "title": "400_Data",
    "section": "the data",
    "text": "the data\n\nfour_hund_data &lt;- read.csv(\"/Users/sambutler/Desktop/400 Data - Sheet1.csv\")"
  },
  {
    "objectID": "chess_website.html",
    "href": "chess_website.html",
    "title": "Tidy Tuesday Chess",
    "section": "",
    "text": "this data comes from around 20,000 games collected from a selection of users on the site Lichess.org.\n\nchess &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-01/chess.csv')\n\nI want to see how often black and white win, and whether rating has anything to do with it\n\n\n\n# isolate wins based on color and rating\nchess_new &lt;- chess %&gt;%\n  mutate(\n    white_win_higher_rating = case_when(\n      winner == \"white\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    white_win_lower_rating = case_when(\n      winner == \"white\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_higher_rating = case_when(\n      winner == \"black\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_lower_rating = case_when(\n      winner == \"black\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ))\n# summarize the counts in a new dataframe \ncounts_summary &lt;- chess_new %&gt;%\n  summarize(\n    white_win_higher_rating = sum(white_win_higher_rating == TRUE),\n    white_win_lower_rating = sum(white_win_lower_rating == TRUE),\n    black_win_higher_rating = sum(black_win_higher_rating == TRUE),\n    black_win_lower_rating = sum(black_win_lower_rating == TRUE)\n  )\n# pivot long so we can plot\ncounts_summary_long &lt;- counts_summary %&gt;%\n  pivot_longer(cols = everything(),\n               names_to = \"conditions\",\n               values_to = \"count\")\n\n# calculate percentages\ncounts_summary_long &lt;- counts_summary_long %&gt;%\n  mutate(percentage = count/sum(count) * 100) %&gt;%\n  mutate(percentage = paste0(round(percentage, 1), \"%\"))\n\n\n# vector for fill colors\nbw_vector &lt;- c(\"black\", \"black\", \"white\", \"white\")\n\ncounts_summary_long %&gt;%\n  ggplot(aes(x = conditions, y = count, fill = conditions)) +\n  geom_col() + \n  coord_cartesian(ylim = c(2000, NA)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylab(\"number of wins\") +\n  scale_x_discrete(labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\")) +\n  scale_fill_manual(values = bw_vector, labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\"), guide = \"none\") +\n  geom_label(aes(label = percentage), vjust = 2, color = \"red\") +\n  ggtitle(\"wins by rating and color\") \n\n\n\n\n\n\n\n\n\n\n\n\n# for alluvial we need three strata: winner/loser, color, and rating\nalluvial_chess &lt;- chess_new %&gt;%\n  mutate(loser = case_when(\n    winner == \"white\" ~ \"black\",\n    winner == \"black\" ~ \"white\"\n  )) %&gt;%\n  mutate(winner_rating = case_when(\n    winner == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    winner == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  mutate(loser_rating = case_when(\n    loser == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    loser == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  select(winner, loser, winner_rating, loser_rating) %&gt;%\n  drop_na()\n\nrating &lt;- c(alluvial_chess$winner_rating, alluvial_chess$loser_rating)\ncolor &lt;- c(alluvial_chess$winner, alluvial_chess$loser)\n\n\nnew_alluvial_chess &lt;- alluvial_chess %&gt;%\n  data.frame(rating = rating, color = color) \n\nprint(nrow(new_alluvial_chess))\n\n[1] 37836\n\n# 37,836\n# the way the data frame is constructed, the first half are wins and the rest losses\nwins &lt;- rep(\"win\", 37836/2)\nlosses&lt;- rep(\"loss\", 37836/2)\noutcome &lt;- c(wins, losses)\n\nnew_alluvial_chess &lt;- new_alluvial_chess %&gt;%\n  mutate(outcome = outcome)\n\n\n# now to plot\nnew_alluvial_chess %&gt;%\nggplot(aes(axis1 = color, axis2 = rating, axis3 = outcome)) +\n  geom_alluvium(aes(fill = color)) +\n  geom_stratum() +\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum))) +\n  scale_x_discrete(limits = c(\"Color\", \"Rating\", \"Outcome\"), expand = c(0.15, 0.05)) +\n  ggtitle(\"Alluvial Plot of Chess Outcomes\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nthe flows between the second and third strata are sort of a formality because each time black wins and has a higher rating, it is reflected by white losing with a lower rating."
  },
  {
    "objectID": "chess_website.html#i-want-to-see-how-often-black-and-white-win-and-whether-rating-has-anything-to-do-with-it",
    "href": "chess_website.html#i-want-to-see-how-often-black-and-white-win-and-whether-rating-has-anything-to-do-with-it",
    "title": "chess_website",
    "section": "",
    "text": "# isolate wins based on color and rating\nchess_new &lt;- chess %&gt;%\n  mutate(\n    white_win_higher_rating = case_when(\n      winner == \"white\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    white_win_lower_rating = case_when(\n      winner == \"white\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_higher_rating = case_when(\n      winner == \"black\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_lower_rating = case_when(\n      winner == \"black\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ))\n# summarize the counts in a new dataframe \ncounts_summary &lt;- chess_new %&gt;%\n  summarize(\n    white_win_higher_rating = sum(white_win_higher_rating == TRUE),\n    white_win_lower_rating = sum(white_win_lower_rating == TRUE),\n    black_win_higher_rating = sum(black_win_higher_rating == TRUE),\n    black_win_lower_rating = sum(black_win_lower_rating == TRUE)\n  )\n# pivot long so we can plot\ncounts_summary_long &lt;- counts_summary %&gt;%\n  pivot_longer(cols = everything(),\n               names_to = \"conditions\",\n               values_to = \"count\")\n\n# calculate percentages\ncounts_summary_long &lt;- counts_summary_long %&gt;%\n  mutate(percentage = count/sum(count) * 100) %&gt;%\n  mutate(percentage = paste0(round(percentage, 1), \"%\"))\n\n\n# vector for fill colors\nbw_vector &lt;- c(\"black\", \"black\", \"white\", \"white\")\n\ncounts_summary_long %&gt;%\n  ggplot(aes(x = conditions, y = count, fill = conditions)) +\n  geom_col() + \n  coord_cartesian(ylim = c(2000, NA)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylab(\"number of wins\") +\n  scale_x_discrete(labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\")) +\n  scale_fill_manual(values = bw_vector, labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\")) +\n  geom_label(aes(label = percentage), vjust = 2, color = \"red\") +\n  ggtitle(\"wins by rating and color\") \n\n\n\n\n\n\n\n\n\n\n\ncustom_labels &lt;- c(\"black higher rating\", \"black lower rating\", \"white higher rating\", \"white lower rating\")\n\ncounts_summary_long %&gt;%\nggplot(aes(x = \"\", y = count, fill = conditions)) +\n  geom_bar(stat = \"identity\", width = 1) +  \n  coord_polar(\"y\") +\n  theme_void() +\n  geom_text(aes(label = percentage), \n            position = position_stack(vjust = 0.25), color = \"white\") +\n  scale_fill_manual(values = wes_palette(\"GrandBudapest1\", n = 4), labels = custom_labels)"
  },
  {
    "objectID": "Countries 11:12:24.html",
    "href": "Countries 11:12:24.html",
    "title": "Countries 11/12/24",
    "section": "",
    "text": "the data this week contains countries and their corresponding country codes, as well as the subdivisions (provinces, states, etc.) found in each.\n\ncountries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/countries.csv') %&gt;%\n  mutate(name = case_when(\n    !is.na(common_name) ~ common_name,\n    TRUE ~ name\n  ))\ncountry_subdivisions &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/country_subdivisions.csv')\nformer_countries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/former_countries.csv')\n\nI want to count the number of subdivisions in each country and then plot them with a color gradient corresponding to the number of subdivisions"
  },
  {
    "objectID": "Countries 11:12:24.html#the-data",
    "href": "Countries 11:12:24.html#the-data",
    "title": "Countries 11/12/24",
    "section": "",
    "text": "the data this week contains countries and their corresponding country codes, as well as the subdivisions (provinces, states, etc.) found in each.\n\ncountries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/countries.csv') %&gt;%\n  mutate(name = case_when(\n    !is.na(common_name) ~ common_name,\n    TRUE ~ name\n  ))\ncountry_subdivisions &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/country_subdivisions.csv')\nformer_countries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/former_countries.csv')\n\nI want to count the number of subdivisions in each country and then plot them with a color gradient corresponding to the number of subdivisions"
  },
  {
    "objectID": "Countries 11:12:24.html#map",
    "href": "Countries 11:12:24.html#map",
    "title": "Countries 11/12/24",
    "section": "map",
    "text": "map\n\n# count number of subdivisions for each country\n\nnum_subdiv &lt;- country_subdivisions %&gt;%\n  count(alpha_2)\n\ndf_num_subdiv &lt;- data.frame(num_subdiv)\n\n# add to original data frame\ncountries &lt;- countries %&gt;%\n  left_join(df_num_subdiv, by = \"alpha_2\")\n\n\nworld &lt;- map_data(\"world\")\n\ndf_country_subdiv &lt;- countries %&gt;%\n  select(name, n)\n\ncolnames(df_country_subdiv) &lt;- c(\"region\", \"subdivisions\")\n\n# match country names between the two data sets\ndf_country_subdiv &lt;- df_country_subdiv %&gt;%\n  mutate(region = case_when(\n    region == \"Russian Federation\" ~ \"Russia\",\n    region == \"United States\" ~ \"USA\",\n    region == \"Congo, The Democratic Republic of the\" ~ \"Democratic Republic of the Congo\",\n    region == \"Côte d'Ivoire\" ~ \"Ivory Coast\",\n    region == \"Türkiye\" ~ \"Turkey\",\n    region == \"Congo\" ~ \"Republic of Congo\",\n    region == \"Czechia\" ~ \"Czech Republic\",\n    TRUE ~ region\n  ))\n\nworld &lt;- world %&gt;%\n  left_join(df_country_subdiv, by = \"region\")\n\n\nworld %&gt;%\n  ggplot() + \n  geom_map(map = world, \n    aes(long, lat, map_id = region, fill = subdivisions))"
  },
  {
    "objectID": "chess_website.html#the-data",
    "href": "chess_website.html#the-data",
    "title": "Tidy Tuesday Chess",
    "section": "",
    "text": "this data comes from around 20,000 games collected from a selection of users on the site Lichess.org.\n\nchess &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-01/chess.csv')\n\nI want to see how often black and white win, and whether rating has anything to do with it\n\n\n\n# isolate wins based on color and rating\nchess_new &lt;- chess %&gt;%\n  mutate(\n    white_win_higher_rating = case_when(\n      winner == \"white\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    white_win_lower_rating = case_when(\n      winner == \"white\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_higher_rating = case_when(\n      winner == \"black\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_lower_rating = case_when(\n      winner == \"black\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ))\n# summarize the counts in a new dataframe \ncounts_summary &lt;- chess_new %&gt;%\n  summarize(\n    white_win_higher_rating = sum(white_win_higher_rating == TRUE),\n    white_win_lower_rating = sum(white_win_lower_rating == TRUE),\n    black_win_higher_rating = sum(black_win_higher_rating == TRUE),\n    black_win_lower_rating = sum(black_win_lower_rating == TRUE)\n  )\n# pivot long so we can plot\ncounts_summary_long &lt;- counts_summary %&gt;%\n  pivot_longer(cols = everything(),\n               names_to = \"conditions\",\n               values_to = \"count\")\n\n# calculate percentages\ncounts_summary_long &lt;- counts_summary_long %&gt;%\n  mutate(percentage = count/sum(count) * 100) %&gt;%\n  mutate(percentage = paste0(round(percentage, 1), \"%\"))\n\n\n# vector for fill colors\nbw_vector &lt;- c(\"black\", \"black\", \"white\", \"white\")\n\ncounts_summary_long %&gt;%\n  ggplot(aes(x = conditions, y = count, fill = conditions)) +\n  geom_col() + \n  coord_cartesian(ylim = c(2000, NA)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylab(\"number of wins\") +\n  scale_x_discrete(labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\")) +\n  scale_fill_manual(values = bw_vector, labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\"), guide = \"none\") +\n  geom_label(aes(label = percentage), vjust = 2, color = \"red\") +\n  ggtitle(\"wins by rating and color\") \n\n\n\n\n\n\n\n\n\n\n\n\n# for alluvial we need three strata: winner/loser, color, and rating\nalluvial_chess &lt;- chess_new %&gt;%\n  mutate(loser = case_when(\n    winner == \"white\" ~ \"black\",\n    winner == \"black\" ~ \"white\"\n  )) %&gt;%\n  mutate(winner_rating = case_when(\n    winner == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    winner == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  mutate(loser_rating = case_when(\n    loser == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    loser == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  select(winner, loser, winner_rating, loser_rating) %&gt;%\n  drop_na()\n\nrating &lt;- c(alluvial_chess$winner_rating, alluvial_chess$loser_rating)\ncolor &lt;- c(alluvial_chess$winner, alluvial_chess$loser)\n\n\nnew_alluvial_chess &lt;- alluvial_chess %&gt;%\n  data.frame(rating = rating, color = color) \n\nprint(nrow(new_alluvial_chess))\n\n[1] 37836\n\n# 37,836\n# the way the data frame is constructed, the first half are wins and the rest losses\nwins &lt;- rep(\"win\", 37836/2)\nlosses&lt;- rep(\"loss\", 37836/2)\noutcome &lt;- c(wins, losses)\n\nnew_alluvial_chess &lt;- new_alluvial_chess %&gt;%\n  mutate(outcome = outcome)\n\n\n# now to plot\nnew_alluvial_chess %&gt;%\nggplot(aes(axis1 = color, axis2 = rating, axis3 = outcome)) +\n  geom_alluvium(aes(fill = color)) +\n  geom_stratum() +\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum))) +\n  scale_x_discrete(limits = c(\"Color\", \"Rating\", \"Outcome\"), expand = c(0.15, 0.05)) +\n  ggtitle(\"Alluvial Plot of Chess Outcomes\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nthe flows between the second and third strata are sort of a formality because each time black wins and has a higher rating, it is reflected by white losing with a lower rating."
  },
  {
    "objectID": "400 Data.html",
    "href": "400 Data.html",
    "title": "400 Data",
    "section": "",
    "text": "the data\nthe data comes from the Pomona-Pitzer track team which is a Division 3 collegiate program. much of it is times collected through a laser timing system used on days when the team is doing short-sprinting work. An interest of this analysis is to see how the success of 400 meter athletes in the short-sprinting work compares to their abilities in the actual 400 meter races. This is of interest because the 400 is a long enough event that it requires both aerobic and anaerobic strengths, the balance of which can vary from athlete to athlete. the data is too small to make any legitimate conclusions, but will be cool to explore nonetheless!\n\n\nstanding 30’s vs. fly 30’s\nhow do both standing and flying 30 meter times correspond to 400 performance?\n\n# first find average of five fastest times in each 30m category\nthirties &lt;- four_hund_data[, grep(\"30\", names(four_hund_data))] \n  \n# replace \"NA\" with 0 so that we can order the columns\nthirties[is.na(thirties)] &lt;- 0\n\nordered_thirties &lt;- as.data.frame(apply(thirties, 2, sort))\n\n# finding the 5 lowest values\nfind_five_lowest_non_zero &lt;- function(column_data) {\n  non_zero_values &lt;- column_data[column_data != 0]\n  sorted_values &lt;- sort(non_zero_values)\n  five_lowest_values &lt;- head(sorted_values, 5)\n  return(five_lowest_values)\n}\n\nfastest_five &lt;- apply(ordered_thirties, 2, find_five_lowest_non_zero) \n\n# in order to find the average of the fastest five, we need all vectors to actually be five values\n# finding the max_length\nmax_length &lt;- max(sapply(fastest_five, length))\n\n# pad vectors with NAs to make them equal length\npadded_list &lt;- lapply(fastest_five, function(x) {\n  length(x) &lt;- max_length\n  return(x)\n})\n\n# convert padded list to dataframe\nfastest_five_df &lt;- data.frame(padded_list)\n\n# now we can calculate the averages\ntop_five_avgs &lt;- colMeans(fastest_five_df, na.rm = TRUE)\n\ntop_five_avgs_df &lt;- data.frame(top_five_avgs)\n\nnow we can get our 400 performances\n\nfour_hundreds &lt;- four_hund_data[, grep(\"400\", names(four_hund_data))] \n\n# get the fastest performances\nmin_values &lt;- apply(four_hundreds, 2, min, na.rm = TRUE)\n\nfastest_four_hundreds &lt;- data.frame(min_values)\n\n\n# want to make a dataframe that allows us to compare 30s and 400s\nstand_thirties &lt;- top_five_avgs_df[seq(1, nrow(top_five_avgs_df), by = 2), ]\nfly_thirties &lt;- top_five_avgs_df[seq(2, nrow(top_five_avgs_df), by = 2), ]\n\nfastest_stand_thirties &lt;- data.frame(stand_thirties)\nfastest_fly_thirties &lt;- data.frame(fly_thirties)\n\n\ntotal_df &lt;- cbind(fastest_four_hundreds, fastest_stand_thirties, fastest_fly_thirties) %&gt;%\n  mutate(athletes = c(\"Sam\", \"Jake\", \"Fox\", \"Jalen\", \"Rylan\", \"Seb\", \"Olivia\", \"Nicole\", \"Kensi\", \"Anna\"))\n\n\ntotal_df %&gt;%\n  ggplot() +\n  geom_col(aes(x = stand_thirties, y = min_values, fill = athletes)) +\nscale_fill_manual(values = c(\"Sam\" = \"black\", \"Jake\" = \"magenta\", \"Fox\" = \"purple\", \"Seb\" = \"darkblue\", \"Jalen\" = \"red\", \"Rylan\" = \"maroon\", \"Olivia\" = \"lightgreen\", \"Nicole\" = \"green\", \"Kensi\" = \"darkgreen\", \"Anna\" = \"orange\"),\n                     breaks = c(\"Jake\", \"Sam\",  \"Seb\", \"Fox\", \"Jalen\", \"Rylan\", \"Kensi\", \"Olivia\", \"Anna\", \"Nicole\")) +\n  xlab(\"standing 30 meter PRs\") +\n  ylab(\"400 meter PRs\") +\n  coord_cartesian(ylim = c(45, 65))\n\n\n\n\n\n\n\n\nathletes with lower bars relative to those clustered around them, (Sam, Fox, & Olivia), are more “strength based” athletes. they have better 400 meter PRs with the same acceleration as those around them. so it is likely that their strength comes from somewhere else.\nnow we might want to see how fly 30 Meter times compare to 400 meter PRs. since the fly times tell us more about max velocity than they do about acceleration, they might be more informative.\n\ntotal_df %&gt;%\n  ggplot() +\n  geom_col(aes(x = fly_thirties, y = min_values, fill = athletes), width = 0.005) +\n  scale_fill_manual(values = c(\"Sam\" = \"black\", \"Jake\" = \"magenta\", \"Fox\" = \"purple\", \"Seb\" = \"darkblue\", \"Jalen\" = \"red\", \"Rylan\" = \"maroon\", \"Olivia\" = \"lightgreen\", \"Nicole\" = \"green\", \"Kensi\" = \"darkgreen\", \"Anna\" = \"orange\"),\n                     breaks = c(\"Jake\", \"Sam\", \"Seb\", \"Jalen\", \"Fox\", \"Rylan\", \"Olivia\", \"Kensi\", \"Nicole\", \"Anna\")) +\n  xlab(\"fly 30 meter PRs\") +\n  ylab(\"400 meter PRs\") +\n  coord_cartesian(ylim = c(45, 65)) \n\n\n\n\n\n\n\n\nSam and Olivia’s fly 30 meter PRs move them closer to the fast end of their respective groups which tells us that max velocity might correspond more directly with their 400 meter ability. Fox however is still in a similar spot relative to the others, which makes sense because he is historically an 800/1500 meter runner so his strengths are truly more aerobic."
  },
  {
    "objectID": "Countries.html",
    "href": "Countries.html",
    "title": "Countries 11/12/24",
    "section": "",
    "text": "The data this week contains countries and their corresponding country codes, as well as the subdivisions (provinces, states, etc.) found in each.\n\ncountries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/countries.csv') %&gt;%\n  mutate(name = case_when(\n    !is.na(common_name) ~ common_name,\n    TRUE ~ name\n  ))\ncountry_subdivisions &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/country_subdivisions.csv')\nformer_countries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/former_countries.csv')\n\nI want to count the number of subdivisions in each country and then plot them with a color gradient corresponding to that number."
  },
  {
    "objectID": "Countries.html#the-data",
    "href": "Countries.html#the-data",
    "title": "Countries 11/12/24",
    "section": "",
    "text": "The data this week contains countries and their corresponding country codes, as well as the subdivisions (provinces, states, etc.) found in each.\n\ncountries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/countries.csv') %&gt;%\n  mutate(name = case_when(\n    !is.na(common_name) ~ common_name,\n    TRUE ~ name\n  ))\ncountry_subdivisions &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/country_subdivisions.csv')\nformer_countries &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-11-12/former_countries.csv')\n\nI want to count the number of subdivisions in each country and then plot them with a color gradient corresponding to that number."
  },
  {
    "objectID": "Countries.html#map",
    "href": "Countries.html#map",
    "title": "Countries 11/12/24",
    "section": "map",
    "text": "map\n\n# count number of subdivisions for each country\n\nnum_subdiv &lt;- country_subdivisions %&gt;%\n  count(alpha_2)\n\ndf_num_subdiv &lt;- data.frame(num_subdiv)\n\n# add to original data frame\ncountries &lt;- countries %&gt;%\n  left_join(df_num_subdiv, by = \"alpha_2\")\n\n\nworld &lt;- map_data(\"world\")\n\ndf_country_subdiv &lt;- countries %&gt;%\n  select(name, n)\n\ncolnames(df_country_subdiv) &lt;- c(\"region\", \"subdivisions\")\n\n# match country names between the two data sets\ndf_country_subdiv &lt;- df_country_subdiv %&gt;%\n  mutate(region = case_when(\n    region == \"Russian Federation\" ~ \"Russia\",\n    region == \"United States\" ~ \"USA\",\n    region == \"Congo, The Democratic Republic of the\" ~ \"Democratic Republic of the Congo\",\n    region == \"Côte d'Ivoire\" ~ \"Ivory Coast\",\n    region == \"Türkiye\" ~ \"Turkey\",\n    region == \"Congo\" ~ \"Republic of Congo\",\n    region == \"Czechia\" ~ \"Czech Republic\",\n    TRUE ~ region\n  ))\n\nworld &lt;- world %&gt;%\n  left_join(df_country_subdiv, by = \"region\")\n\n\nworld %&gt;%\n  ggplot() + \n  geom_map(map = world, \n    aes(long, lat, map_id = region, fill = subdivisions))"
  },
  {
    "objectID": "Chess.html",
    "href": "Chess.html",
    "title": "Chess 10/1/24",
    "section": "",
    "text": "This data comes from around 20,000 games collected from a selection of users on the site Lichess.org.\n\nchess &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-01/chess.csv')\n\nI want to see how often black and white win, and whether rating has anything to do with it."
  },
  {
    "objectID": "Chess.html#the-data",
    "href": "Chess.html#the-data",
    "title": "Chess 10/1/24",
    "section": "",
    "text": "This data comes from around 20,000 games collected from a selection of users on the site Lichess.org.\n\nchess &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-01/chess.csv')\n\nI want to see how often black and white win, and whether rating has anything to do with it."
  },
  {
    "objectID": "Chess.html#bar-plot",
    "href": "Chess.html#bar-plot",
    "title": "Chess 10/1/24",
    "section": "bar plot",
    "text": "bar plot\n\n# isolate wins based on color and rating\nchess_new &lt;- chess %&gt;%\n  mutate(\n    white_win_higher_rating = case_when(\n      winner == \"white\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    white_win_lower_rating = case_when(\n      winner == \"white\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_higher_rating = case_when(\n      winner == \"black\" & white_rating &lt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ), \n    black_win_lower_rating = case_when(\n      winner == \"black\" & white_rating &gt; black_rating ~ TRUE,\n      TRUE ~ FALSE\n    ))\n# summarize the counts in a new dataframe \ncounts_summary &lt;- chess_new %&gt;%\n  summarize(\n    white_win_higher_rating = sum(white_win_higher_rating == TRUE),\n    white_win_lower_rating = sum(white_win_lower_rating == TRUE),\n    black_win_higher_rating = sum(black_win_higher_rating == TRUE),\n    black_win_lower_rating = sum(black_win_lower_rating == TRUE)\n  )\n# pivot long so we can plot\ncounts_summary_long &lt;- counts_summary %&gt;%\n  pivot_longer(cols = everything(),\n               names_to = \"conditions\",\n               values_to = \"count\")\n\n# calculate percentages\ncounts_summary_long &lt;- counts_summary_long %&gt;%\n  mutate(percentage = count/sum(count) * 100) %&gt;%\n  mutate(percentage = paste0(round(percentage, 1), \"%\"))\n\n\n# vector for fill colors\nbw_vector &lt;- c(\"black\", \"black\", \"white\", \"white\")\n\ncounts_summary_long %&gt;%\n  ggplot(aes(x = conditions, y = count, fill = conditions)) +\n  geom_col() + \n  coord_cartesian(ylim = c(2000, NA)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylab(\"number of wins\") +\n  scale_x_discrete(labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\")) +\n  scale_fill_manual(values = bw_vector, labels = c(\n    \"white_win_higher_rating\" = \"higher rating\",\n    \"white_win_lower_rating\" = \"lower rating\",\n    \"black_win_higher_rating\" = \"higher rating\",\n    \"black_win_lower_rating\" = \"lower rating\"), guide = \"none\") +\n  geom_label(aes(label = percentage), vjust = 2, color = \"red\") +\n  ggtitle(\"wins by rating and color\")"
  },
  {
    "objectID": "Chess.html#alluvial-plot",
    "href": "Chess.html#alluvial-plot",
    "title": "Chess 10/1/24",
    "section": "alluvial plot",
    "text": "alluvial plot\n\n# for alluvial we need three strata: winner/loser, color, and rating\nalluvial_chess &lt;- chess_new %&gt;%\n  mutate(loser = case_when(\n    winner == \"white\" ~ \"black\",\n    winner == \"black\" ~ \"white\"\n  )) %&gt;%\n  mutate(winner_rating = case_when(\n    winner == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    winner == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    winner == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  mutate(loser_rating = case_when(\n    loser == \"white\" & white_rating &gt; black_rating ~ \"higher\",\n    loser == \"white\" & white_rating &lt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &gt; black_rating ~ \"lower\",\n    loser == \"black\" & white_rating &lt; black_rating ~ \"higher\"\n  )) %&gt;%\n  select(winner, loser, winner_rating, loser_rating) %&gt;%\n  drop_na()\n\nrating &lt;- c(alluvial_chess$winner_rating, alluvial_chess$loser_rating)\ncolor &lt;- c(alluvial_chess$winner, alluvial_chess$loser)\n\n\nnew_alluvial_chess &lt;- alluvial_chess %&gt;%\n  data.frame(rating = rating, color = color) \n\nprint(nrow(new_alluvial_chess))\n\n[1] 37836\n\n# 37,836\n# the way the data frame is constructed, the first half are wins and the rest losses\nwins &lt;- rep(\"win\", 37836/2)\nlosses&lt;- rep(\"loss\", 37836/2)\noutcome &lt;- c(wins, losses)\n\nnew_alluvial_chess &lt;- new_alluvial_chess %&gt;%\n  mutate(outcome = outcome)\n\n\n# now to plot\nnew_alluvial_chess %&gt;%\nggplot(aes(axis1 = color, axis2 = rating, axis3 = outcome)) +\n  geom_alluvium(aes(fill = color)) +\n  geom_stratum() +\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum))) +\n  scale_x_discrete(limits = c(\"Color\", \"Rating\", \"Outcome\"), expand = c(0.15, 0.05)) +\n  ggtitle(\"Alluvial Plot of Chess Outcomes\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nThis plot is not very informative since each game contains both values of each variable. For example, if there is a game where black has a higher rating and loses, then necessarily, in the same game, white had a lower rating and won, so the whole plot is symmetric. Nice to look at though!"
  }
]