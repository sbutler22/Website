<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research – Website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Images/liberty_bell.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="index.html" class="back-home">← Back to home</a></p>
<p>This research was done in collaboration with Phineus Choi, Thomas Matheis, and Mira Terdiman under the advisement of Jo Hardin, in the summer and fall of 2025. The paper below has been submitted to the Journal of Open Source Software (JOSS).</p>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>The R package <strong>sicegar</strong> aims to quantify time intensity data by using sigmoidal and double sigmoidal curves. <strong>sicegar</strong> fits sigmoidal and double sigmoidal curves on intensity vs time data. Each of the fits are used to make a decision on which model best describes the data. The method was originally developed in the context of single-cell viral growth analysis (for details, see <span class="citation" data-cites="caglar2018">@caglar2018</span>), and the package name stands for “SIngle CEll Growth Analysis in R”. Beyond <strong>sicegar</strong>’s ability to categorize fits, it also provides parameter estimations for each curve which can also provide important information to researchers.</p>
<p>In particular, the sigmoidal function is given as follows (with parameters estimated using the Levenberg-Marquardt algorithm <span class="citation" data-cites="levenberg1944 marquardt1963">[@levenberg1944;@marquardt1963]</span>). <span class="math inline">\(h_0\)</span> represents the lower asymptote (as <span class="math inline">\(x\)</span> approaches negative infinity). <span class="math inline">\(t_1\)</span> is the onset time, the midpoint between <span class="math inline">\(h_0\)</span> and <span class="math inline">\(h_1\)</span>. <span class="math inline">\(a\)</span> determines the magnitude of the slope of the sigmoidal curve. <span class="math inline">\(h_1\)</span> is the upper asymptote (as <span class="math inline">\(x\)</span> approaches positive infinity).</p>
<p><span class="math inline">\(I(x) = h_0 + \frac{h_1-h_0}{1 + e^{-a(x - t_1)}}\)</span></p>
<p><strong>Figure 1</strong> Visualization of the sigmoidal curve and related parameter values.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sigmoidal_curve.png" class="img-fluid figure-img"></p>
<figcaption>Sigmoidal curve.</figcaption>
</figure>
</div>
<p>The parameter <span class="math inline">\(t_1\)</span> marks both the inflection point of the single-sigmoid curve as well as the midpoint between <span class="math inline">\(h_0\)</span> and <span class="math inline">\(h_1.\)</span> For example, in the setting of modeling RNA-seq data, extracting <span class="math inline">\(t_1\)</span> from a <strong>sicegar</strong> fit allows us to estimate the onset time of RNA expression.</p>
<p>A similar, but slightly more complicated, formula for the double sigmoidal function is also used for parameter estimation in <strong>sicegar</strong>. In the original implementation of <strong>sicegar</strong>, the parameter <span class="math inline">\(h_0\)</span> is set to zero for both the sigmoidal and double-sigmoidal models.</p>
<p><span class="citation" data-cites="Adams">@Adams</span> uses <strong>sicegar</strong> to investigate the onset time of RNA expression in genes in <em>E. coli</em> undergoing stress. They observed limitations in <strong>sicegar</strong>’s fits, which motivated the improvements proposed in this paper. Our primary update to the <strong>sicegar</strong> package is the estimation of an additional parameter, <span class="math inline">\(h_0\)</span>, which is the lower asymptote of both the sigmoidal and double-sigmoidal curves, which had previously been set equal to 0. Based on simulated data, the free estimation of <span class="math inline">\(h_0\)</span> provides both a better fit (lower SSE) and more accurate parameter estimations than when <span class="math inline">\(h_0\)</span> is forced to be equal to zero. Other smaller adjustments to the package include improvements to how one of the parameters is un-normalized and adjusting the threshold for an error catch. For backward compatibility, the updated package is designed so that the <span class="math inline">\(h_0 = 0\)</span> is the default value. As seen in <strong>Figure 1</strong>, the argument <code>use_h0</code> in the overarching function <code>fitAndCategorize</code> allows the user to decide whether to allow the package to estimate <span class="math inline">\(h_0\)</span>.</p>
</section>
<section id="statement-of-need" class="level1">
<h1>Statement of Need</h1>
<p><span class="citation" data-cites="caglar2018">@caglar2018</span> discuss <strong>sicegar</strong>’s ability to correctly identify sigmoidal and double-sigmoidal curves on simulated data. They report, “Overall, we can conclude that our algorithm results in reliable fits, that it fails gradually with increasing noise levels, and that it is conservative in assessing whether it has correctly identified a sigmoidal or double-sigmoidal curve or not.” The focus of their results is on whether <strong>sicegar</strong> is able to correctly identify sigmoidal and double-sigmoidal curves on simulated data, not on whether it is able to accurately report parameter estimations. Though they acknowledge <strong>sicegar</strong>’s ability to estimate parameters associated with sigmoidal and double-sigmoidal curves, they do not report on the accuracy of the parameter estimates.</p>
<p>In dozens of research projects that use <strong>sicegar</strong> for modeling time-intensity data, researchers are interested in extracting specific parameter estimates, like midpoints and slopes, as the parameter values represent biologically meaningful information. <span class="citation" data-cites="Adams">@Adams</span> extracted midpoint values (<span class="math inline">\(t_1\)</span>) to investigate onset time of RNA expression in genes in <em>E. coli</em> undergoing stress. <span class="citation" data-cites="wittemeier">@wittemeier</span> used <strong>sicegar</strong> to estimate molar carbon assimilation. They used <strong>sicegar</strong>’s estimation of maximum slope in sigmoidal curves to understand maximum assimilation rate, and midpoints (<span class="math inline">\(t_1\)</span>) in sigmoidal curves to extract the point at which maximum assimilation is reached. <span class="citation" data-cites="rajarathinam">@rajarathinam</span> also used <strong>sicegar</strong> to analyze carbon assimilation and to extract estimations of maximum slope. Our addition of <span class="math inline">\(h_0\)</span> to the set of estimated parameters greatly improves the package’s ability to provide accurate parameter estimations. Through simulations, with varying levels of noise, generating parameters, and both sigmoidal and double sigmoidal curves, we were able to accurately estimate all parameter estimates, even when the lower asymptote is not zero. Though the categorization of the model as sigmoidal or double-sigmoidal is hugely important, it is not the only important aspect of the <strong>sicegar</strong> modeling. Our updated implementation, which includes the estimation of the lower asymptote, is prevailingly important, and thus our adjustments fit the needs of current research.</p>
<p>As previously mentioned, <strong>sicegar</strong> fits time-intensity data to single and double sigmoid curves, which allows users to extract key parameters including the onset time of RNA expression in specific genes <span class="citation" data-cites="caglar2018">[@caglar2018]</span>. To better contextualize the relevance of sigmoid parameters to onset time, we can map the parameters described in equation <span class="math inline">\(I(x)\)</span> to a plot of a typical single-sigmoid function:</p>
</section>
<section id="features" class="level1">
<h1>Features</h1>
<section id="core-functions" class="level3">
<h3 class="anchored" data-anchor-id="core-functions">Core Functions</h3>
<p><code>fitAndCategorize</code>, the overarching function in <strong>sicegar</strong>, takes time-intensity data as an argument and runs the data through a series of nested functions. The structure of this process is outlined in <strong>Figure 1</strong>. First, the data are normalized in the function <code>normalizeData</code> (1). Then they are passed through <code>multipleFitFunction</code> (2) which uses the Levenberg-Marquardt algorithm <span class="citation" data-cites="levenberg1944 marquardt1963">[@levenberg1944;@marquardt1963]</span> to fit both sigmoidal and double-sigmoidal curves to the data, (3), (4). Additional parameters are then added to the output vector in <code>parameterCalculations</code> to prepare the model to be plotted. The user decides whether to allow the function to estimate <span class="math inline">\(h_0\)</span> using the argument <code>use_h0 = TRUE</code> in <code>fitAndCategorize</code>. If <code>use_h0</code> is set to <code>FALSE</code> (the default), the algorithm will run <strong>sicegar</strong> as it was originally written, with <span class="math inline">\(h_0\)</span> fixed at zero. If they choose to allow the function to estimate <span class="math inline">\(h_0\)</span>, it will follow the same function flow, except that each function will account for the estimation of <span class="math inline">\(h_0\)</span>.</p>
</section>
<section id="novel-contributions" class="level3">
<h3 class="anchored" data-anchor-id="novel-contributions">Novel Contributions</h3>
<p>Each function in <strong>sicegar</strong> was rewritten to include the parameter <span class="math inline">\(h_0\)</span> in addition to a some small technical changes to the functions. Our new version is outlined in the right-hand branch of <strong>Figure 1</strong>.</p>
<p><strong>Figure 2</strong> Structure of the <code>fitAndCategorize</code> function.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/h0_alg.png" class="img-fluid figure-img"></p>
<figcaption>Structure of the <code>fitAndCategorize</code> function.</figcaption>
</figure>
</div>
</section>
</section>
<section id="example" class="level1">
<h1>Example</h1>
<p>To demonstrate the difference between the functionality when <span class="math inline">\(h_0 = 0\)</span> versus when <span class="math inline">\(h_0\)</span> is freely estimated, we present a small simulation. The data were simulated by using a base sigmoidal function given by <span class="math inline">\(I(x)\)</span> and visualized in <strong>Figure 1</strong>. The parameters in our simulation are $h_0 = $, $h_1 = $, $a = $, and $t_1 = $. At each of <em>somenumber</em> of time points on the x-axis, we have <em>somenumber</em> of replicates around the sigmoidal model with normal noise that has a standard deviation of <em>somenumber</em>. Our simulation does not prove that estimating <span class="math inline">\(h_0\)</span> freely is always preferable, but it does indicate that there are circumstances in which estimating <span class="math inline">\(h_0\)</span> is important for full approximation of the model.</p>
<p><strong>Figure 3</strong> Sicegar fit for one simulation</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/param_est.png" class="img-fluid figure-img"></p>
<figcaption>Sicegar fit for one simulation.</figcaption>
</figure>
</div>
<p><strong>Figure 3</strong> shows a single simulated dataset with two different sigmoidal fits. The left image requires <span class="math inline">\(h_0 = 0\)</span> and the rest of the function follows from that restriction. The right image allows <span class="math inline">\(h_0\)</span> to be freely estimated, and the other parameters are correspondingly estimated.</p>
<p><strong>Figure 4</strong> Parameter estimates from simulated data.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/param_est.png" class="img-fluid figure-img"></p>
<figcaption>Parameter estimates from simulated data.</figcaption>
</figure>
</div>
<p>For each of 200 simulated sigmoidal datasets, <strong>Figure 4</strong> shows the parameter estimates for each of the four parameters given in <span class="math inline">\(I(x)\)</span> and seen in <strong>Figure 1</strong>. The red vertical line indicates the value of the parameter used for data generation. It should be noted that allowing <span class="math inline">\(h_0\)</span> to be freely estimated provides both more accurate parameter estimations — notably for <span class="math inline">\(t_1\)</span> — and better categorizations of the model (as “sigmoidal” rather than “ambiguous”). Similar results occur when the package is run on simulated data with more noise, as well as on data simulated from the double sigmoidal model.</p>
</section>
<section id="availability" class="level1">
<h1>Availability</h1>
<p>The <strong>sicegar</strong> package is available on CRAN (https://CRAN.R-project.org/package=sicegar) and GitHub (https://github.com/hardin47/sicegar). Documentation, including vignettes and examples, is provided to facilitate adoption.</p>
</section>
<section id="acknowledgements" class="level1">
<h1>Acknowledgements</h1>
<p>The authors gratefully acknowledge Dan Stoebel for bringing the application to our attention and Federica Domecq Lacroze for sharing her explorations of the <strong>sicegar</strong> package.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>